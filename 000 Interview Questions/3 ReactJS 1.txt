### React Fundamentals

Question : 1 : What is React?
Answer : React is a JavaScript library for building user interfaces from reusable components with declarative rendering and state management.

Question : 2 : What is a component in React?
Answer : A component is a self-contained piece of UI defined as a function that returns JSX and can be composed to build complex interfaces.

Question : 3 : What is JSX?
Answer : JSX is a JavaScript syntax extension that lets components return markup using XML-like tags, which React transforms into UI instructions.

Question : 4 : Why must React component names be capitalized?
Answer : Capitalization distinguishes custom React components from built-in HTML tags so React can treat them as component calls rather than DOM elements.

Question : 5 : How are styles added in React?
Answer : Styles can be applied using className for CSS classes and the style prop for inline styles that depend on JavaScript values.

Question : 6 : What are props?
Answer : Props are data passed from a parent component to a child component to configure its behavior and appearance.

Question : 7 : What is state?
Answer : State is component memory managed by Hooks that lets a component remember information like user input across renders.

Question : 8 : How is state created in a function component?
Answer : State is created by calling the useState Hook, which returns a current value and a setter function to trigger re-renders.

Question : 9 : Are multiple instances of the same component isolated in state?
Answer : Yes, each rendered instance of a component gets its own independent state, so they don't affect each other.

Question : 10 : What does lifting state up mean?
Answer : Lifting state up means moving shared state to the nearest common parent so multiple children read and update it consistently via props.

Question : 11 : How does conditional rendering work in React?
Answer : Conditional rendering uses normal JavaScript constructs like if, the ternary operator, or logical \&\& to choose which JSX to render.

Question : 12 : How are lists rendered in React?
Answer : Lists are rendered by mapping arrays to arrays of JSX elements, typically giving each element a unique key.

Question : 13 : What is the key prop used for?
Answer : Keys help React identify items across renders so it can correctly insert, remove, or reorder list elements without losing state.

Question : 14 : Why should keys be stable and unique?
Answer : Stable, unique keys derived from data prevent incorrect state reuse and enable predictable list updates during reordering.

Question : 15 : What is an event handler in React?
Answer : An event handler is a function passed to an event prop like onClick that React calls in response to user actions.

Question : 16 : Why should event handlers be passed, not called, in JSX?
Answer : Passing handlers (without parentheses) lets React call them at the appropriate time, whereas calling them immediately triggers them during rendering.

Question : 17 : What are Hooks in React?
Answer : Hooks are functions that let components use React features such as state, context, effects, refs, and performance optimizations.

Question : 18 : What are the Rules of Hooks?
Answer : Hooks must be called at the top level of components or other Hooks and never inside conditions or loops to ensure consistent call order.

Question : 19 : What does useEffect do?
Answer : useEffect connects a component to external systems by running side effects after rendering and optionally cleaning them up.

Question : 20 : When is a cleanup function used in useEffect?
Answer : The cleanup returned from an effect runs before the effect re-runs and when the component unmounts to tear down subscriptions or other resources.

Question : 21 : When should effects be avoided?
Answer : Avoid effects for internal data flow and computation because effects are escape hatches intended for external systems like network, DOM, or timers.

Question : 22 : What is useState’s updater function form?
Answer : The setter can receive a function with the previous state and should return the next state to avoid stale closures or race conditions.

Question : 23 : How does React handle multiple state updates?
Answer : React 18 performs automatic batching to combine multiple state updates into a single render for better performance by default.

Question : 24 : What is useReducer used for?
Answer : useReducer manages complex state by centralizing update logic in a reducer function that returns a new state from an action.

Question : 25 : What is context in React?
Answer : Context lets components read values from distant parents without prop drilling by subscribing to a provided value with useContext.

Question : 26 : What does useContext return?
Answer : useContext reads and subscribes to the nearest matching context value so the component re-renders when the value changes.

Question : 27 : What is a ref in React?
Answer : A ref stores a mutable value, often a DOM node or timer id, that persists across renders without causing re-renders when updated.

Question : 28 : When should refs be used instead of state?
Answer : Use refs for mutable values that are not used to render UI to avoid unnecessary re-renders, reserving state for values that affect rendering.

Question : 29 : What does useRef return?
Answer : useRef returns a {current} object that persists across renders and can hold any mutable value, commonly a DOM element reference.

Question : 30 : What is useImperativeHandle for?
Answer : useImperativeHandle customizes the value exposed to parent refs to limit or shape the imperative API of a child component.

Question : 31 : What is useMemo?
Answer : useMemo caches the result of an expensive calculation and recomputes it only when its dependencies change, reducing unnecessary work.

Question : 32 : What is useCallback?
Answer : useCallback memoizes a function definition so that its identity is stable across renders unless dependencies change, aiding memoized children.

Question : 33 : What problems do useMemo and useCallback solve?
Answer : They avoid recalculations and function identity changes that would otherwise cause avoidable re-renders in optimized components.

Question : 34 : What is useTransition?
Answer : useTransition marks updates as non-urgent transitions so React can keep the UI responsive and avoid jarring loading fallbacks during navigation.

Question : 35 : What is startTransition?
Answer : startTransition wraps a state update to signal it is non-urgent, allowing React to keep already-revealed UI visible while new content loads.

Question : 36 : What is useDeferredValue?
Answer : useDeferredValue lets a part of the UI lag behind by deferring updates to a non-critical value, often used with Suspense to show stale results.

Question : 37 : What is Suspense in React?
Answer : Suspense lets components display a fallback UI while child content is loading and then reveal the real UI when it's ready.

Question : 38 : What kinds of loading can trigger Suspense?
Answer : Suspense works with lazy-loaded component code, Suspense-enabled framework data fetching, and reading cached Promises via use.

Question : 39 : How do nested Suspense boundaries behave?
Answer : Nested boundaries let different parts of the UI reveal progressively, so outer content can appear before inner content that's still loading.

Question : 40 : What does React 18 add regarding Suspense?
Answer : React 18 integrates Suspense with streaming server-side rendering and selective hydration to improve perceived performance during loading.

Question : 41 : What is automatic batching?
Answer : Automatic batching in React 18 groups multiple state updates into a single render even across async boundaries, improving performance.

Question : 42 : What is concurrent rendering?
Answer : Concurrent rendering is an internal capability that allows React to prepare multiple UI versions and prioritize updates when using concurrent features.

Question : 43 : Is concurrent rendering opt-in?
Answer : Yes, concurrent behavior is enabled when using concurrent features like transitions rather than a global “mode”.

Question : 44 : What is the purpose of the fallback prop in Suspense?
Answer : The fallback prop specifies lightweight UI (e.g., a spinner) displayed while children are suspended and is automatically swapped back when ready.

Question : 45 : Does Suspense preserve state for first-time mounting content?
Answer : No, React does not preserve state for content that suspends before it first mounts and will retry rendering from scratch once ready.

Question : 46 : How to avoid replacing revealed UI with a fallback during navigation?
Answer : Wrap navigation state updates in startTransition or use useTransition so React keeps already-visible content while new content loads.

Question : 47 : What is the role of keys in resetting Suspense on navigation?
Answer : Setting a key forces React to treat content as different between navigations so boundaries reset and show appropriate fallbacks.

Question : 48 : What is the children prop?
Answer : children is a special prop that represents nested JSX within a component's opening and closing tags for flexible composition.

Question : 49 : What are fragments in React?
Answer : Fragments let components return multiple elements without extra DOM wrappers using <>...</> in JSX.

Question : 50 : How does React update the UI after setState?
Answer : After calling the state setter, React re-invokes the component to compute new JSX and then updates the DOM to reflect changes.

Question : 51 : What are controlled form inputs?
Answer : Controlled inputs derive their value from state and update state on change so the React state is the single source of truth.

Question : 52 : What are uncontrolled inputs?
Answer : Uncontrolled inputs store their own value in the DOM and can be accessed via refs when React-managed state is unnecessary.

Question : 53 : When should state be immutable?
Answer : State should be treated as immutable and replaced with new objects to enable reliable change detection and predictable updates.

Question : 54 : What does “pure” component logic mean in React?
Answer : Purity means rendering should be free of side effects and depend only on props and state, enabling React's optimizations and predictability.

Question : 55 : Why keep effects separate from rendering?
Answer : Rendering must be pure and synchronous, while effects run after rendering to interact with external systems safely.

Question : 56 : What is useLayoutEffect?
Answer : useLayoutEffect runs before the browser repaints, enabling DOM measurements or layout-sensitive logic that must run synchronously after commit.

Question : 57 : What is useInsertionEffect?
Answer : useInsertionEffect runs before DOM mutations so libraries can insert styles with correct ordering, and it is rarely used in app code.

Question : 58 : What are performance Hooks?
Answer : Performance Hooks like useMemo, useCallback, useTransition, and useDeferredValue help skip unnecessary work and prioritize updates.

Question : 59 : What is the benefit of memoizing functions passed to children?
Answer : Memoizing functions with useCallback stabilizes their identity to prevent memoized children from re-rendering unnecessarily.

Question : 60 : How do transitions improve UX?
Answer : Transitions let urgent updates like typing remain responsive while non-urgent UI like navigation or results lists update without hiding revealed content.

Question : 61 : How can stale content be shown instead of a fallback?
Answer : useDeferredValue keeps a previous value until new data is ready so lists can show stale results instead of a Suspense fallback.

Question : 62 : What does the fallback re-show behavior depend on?
Answer : If content that was revealed suspends again, Suspense shows the fallback unless the update was wrapped in a transition or used a deferred value.

Question : 63 : How does React coordinate reveal within a Suspense boundary?
Answer : By default, all children under a Suspense boundary are revealed together once they are all ready, ensuring coordinated appearance.

Question : 64 : Can Suspense boundaries be moved without changing behavior elsewhere?
Answer : Yes, adding, moving, or deleting Suspense boundaries only affects their subtree and does not change unrelated parts of the app's behavior.

Question : 65 : What is the use Hook?
Answer : use can read values from resources like Promises or context during rendering, enabling Suspense-driven data flows in compatible setups.

Question : 66 : What is the difference between props and state?
Answer : Props are external inputs passed from parents, while state is internal component memory that changes over time and triggers re-renders.

Question : 67 : How should computationally heavy code be handled in React?
Answer : Wrap heavy computations in useMemo to cache results between renders and include precise dependencies to recompute only when needed.

Question : 68 : How to prevent re-renders when passing callbacks?
Answer : Wrap callbacks in useCallback so memoized children that depend on function identity don’t re-render unnecessarily.

Question : 69 : What are custom Hooks?
Answer : Custom Hooks are functions that reuse stateful logic by composing built-in Hooks, enabling clean sharing of behavior across components.

Question : 70 : How to share data across many levels without prop drilling?
Answer : Use context by providing a value at a parent and reading it in children with useContext to subscribe to updates.

Question : 71 : What is the difference between state and refs regarding re-renders?
Answer : Updating state schedules a re-render, while updating a ref’s current value does not trigger re-rendering.

Question : 72 : Why is immutable state important for list updates?
Answer : Immutable updates help React compare previous and next values to apply minimal DOM changes and preserve state correctly.

Question : 73 : How to choose keys for list items?
Answer : Use stable, unique identifiers from the data such as IDs rather than indices, especially when items can be reordered or removed.

Question : 74 : What is the recommended way to handle form input state?
Answer : Use controlled components by binding value to state and updating state in onChange handlers for predictable data flow.

Question : 75 : Why shouldn’t effects orchestrate internal data flow?
Answer : Effects are for external systems, and using them for internal flows complicates logic and can cause redundant work or bugs.

Question : 76 : When does a cleanup run relative to re-renders?
Answer : Cleanups run before the next effect execution and on unmount to dispose resources like subscriptions or timers.

Question : 77 : What is the main purpose of React’s purity rule?
Answer : Purity ensures predictable rendering, easier debugging, and enables React to optimize updates and scheduling effectively.

Question : 78 : What are the major highlights of React 18?
Answer : React 18 adds automatic batching, new concurrent APIs like startTransition, and streaming server rendering integrated with Suspense.

Question : 79 : How does Suspense integrate with server rendering in React 18?
Answer : React 18 supports streaming server rendering with Suspense so server HTML can include fallbacks and progressively hydrate content.

Question : 80 : How can navigation indicate progress with transitions?
Answer : useTransition returns isPending, which can be used to show visual indicators like dimming or spinners during non-urgent navigation updates.

Question : 81 : What is the relationship between transitions and deferred values?
Answer : Both avoid jarring fallbacks by preferring inline indicators, with transitions marking whole updates non-urgent and deferred values lagging specific parts.

Question : 82 : When is a Suspense fallback not shown during a transition?
Answer : React avoids hiding already revealed content during a transition but still shows fallbacks for newly rendered boundaries to keep UI responsive.

Question : 83 : How to reset a Suspense boundary when content identity changes?
Answer : Provide a key that changes with identity (like an ID) so React treats it as different content and resets the boundary.

Question : 84 : What is the recommended granularity of Suspense boundaries?
Answer : Boundaries should match the intended loading sequence rather than wrapping every component to avoid overly granular fallbacks.

Question : 85 : What is the typical use of useId?
Answer : useId generates unique IDs that remain stable across server and client renders, commonly for accessibility attributes.

Question : 86 : What is the difference between urgent and non-urgent updates?
Answer : Urgent updates (like typing) must be synchronous, while non-urgent updates (like complex navigation) can be marked as transitions to prioritize responsiveness.

Question : 87 : Why is the dependency list important in Hooks?
Answer : Dependencies determine when effects, memoized values, or callbacks re-run and must precisely list reactive values used inside.

Question : 88 : How to avoid stale closures in state updates?
Answer : Use the functional updater form setState(prev => next) to ensure the latest state is used when scheduling updates.

Question : 89 : When would useReducer be favored over useState?
Answer : Prefer useReducer when state logic is complex or transitions are driven by actions that benefit from centralized reducer logic.

Question : 90 : How does React decide what to update on the page?
Answer : React compares the previously rendered output to the next output and applies the minimal necessary DOM changes to reflect new JSX.

Question : 91 : What is the rendering process at a high level?
Answer : React calls components to produce JSX (render) and then commits changes to the DOM to update what's visible on the screen.

Question : 92 : What is the purpose of the children composition pattern?
Answer : It allows parent components to control layout while passing arbitrary child content for flexible and reusable UI patterns.

Question : 93 : Why keep render logic pure and side-effect free?
Answer : Pure render logic ensures deterministic output for given inputs and lets React schedule and optimize updates safely.

Question : 94 : What are “escape hatches” in React?
Answer : Effects and refs are escape hatches for interacting with non-React systems like DOM APIs, timers, or network requests.

Question : 95 : How does useDeferredValue affect UX in search?
Answer : It lets inputs update immediately while the results list lags to show stale results until new data loads, avoiding a fallback flash.

Question : 96 : Can Suspense be used without a framework for data fetching today?
Answer : Not yet reliably, as Suspense-enabled data sources outside frameworks are unstable and undocumented pending future APIs.

Question : 97 : What happens to layout effects when suspended content hides?
Answer : React cleans up layout effects when content hides due to suspension and re-fires them when content becomes visible again.

Question : 98 : What is the troubleshooting guidance to avoid fallback flashes?
Answer : Mark updates as non-urgent with startTransition so React avoids replacing visible UI with fallbacks during the update.

Question : 99 : What does the React Reference Overview provide?
Answer : It organizes official API documentation for React, React DOM, Hooks, rules, and tools like the Hooks ESLint plugin.

Question : 100 : Where are all built-in Hooks documented?
Answer : The Built-in React Hooks page lists and explains state, context, ref, effect, performance, and other Hooks with usage guidance.